
### 一条sql语句是如何执行的

server层：
    连接器 
    查询缓存
    分析器
    优化器
    执行器

存储引擎

连接器：负责跟客户端建立连接，获取权限，维持和管理连接

查询缓存：mysql拿到一个查询请求后，会先到查询缓存中看看，之前有没有执行过这条语句。之前执行过的语句及其结果会以key-value的形式，缓存在内存
中，如果有直接返回value。没有的话，接着继续后面的执行阶段。一般不建议使用查询缓存，因为只要表中有一条数据更新，就会清空整张表的查询缓存。对于
更新压力大的数据库来说，查询缓存的命中率非常低。

分析器：进行词法分析（sql语句按空格拆分）、语法分析

优化器：选择索引，或者判断如何执行sql，比如如下语句
select * from t1 join t2 on t1.id=t2.id where t1.a = 10 and t2.b=20
以上语句的执行方式有两种，但是他们的执行效率不同
1、如果先按t1.a=10选取行，然后根据此行的id获取t2的数据，判断t2中对应行b是否等于20
2、如果先按t2.b=20选取行，然后根据此行的id获取t1的数据，判断t1中对应行a是否等于10
优化器的作用就是决定选择哪一种方案。

执行器：开始执行的时候，先判断一下你对这个表有没有执行权限。如果没有，返回没有权限的错误（在工程实现上，如果命中查询缓存，会在查询缓存返回结果
的时候，做权限验证）。调用存储引擎的接口，逐条获取数据
-=089999999999999999999999997
问题
如果表 T 中没有字段 k，而你执行了这个语句 select * from T where k=1, 那肯定是会报“不存在这个列”的错误： 
“Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？
[分析器]

### 一条update语句是如何执行的

两阶段提交
    redo log prepare
    binlog
    redo log commit
    
redo log是innodb存储引擎特有的，做持久化的，是个循环队列（write_pos/checkpoint）
binlog是在server层，用来做归档，数据同步的，是追加写入的

为什么会有两份日志（redo log和binlog）
1、binlog用来做主从同步的，是server层提供的，并不是某个存储引擎特有的。
2、redo log是个循环队列，有容量限制。不能持久保存。

两阶段写入，保证了两份日志之间的逻辑一致。如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。




























